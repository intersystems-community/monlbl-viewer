<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="GMONLBL.Broker">
<Super>%CSP.REST</Super>
<TimeCreated>63160,86030.979011</TimeCreated>

<XData name="UrlMap">
<Description>
The UrlMap determines how a Url should map to a HTTP Method and a Target ClassMethod
indicated by the 'call' attribute. The call attribute is either the name of a method
or the name of a class and method seperated by a ':'.
parameters within the URL preceeded by a ':' will be extracted from the supplied URL
and passed as arguments to the named method.</Description>
<XMLNamespace>http://www.intersystems.com/urlmap</XMLNamespace>
<Data><![CDATA[
<Routes >
<!-- Все группы -->
<Route Url="/status" Method="GET" Call="CheckMonitorStatus"/>
<Route Url="/start" Method="POST" Call="StartMonitor"/>  
<Route Url="/stop" Method="GET" Call="StopMonitor"/> 
<Route Url="/pause" Method="GET" Call="PauseMonitor"/>
<Route Url="/resume" Method="GET" Call="ResumeMonitor"/>
<Route Url="/reset" Method="GET" Call="ResetStats"/>
<Route Url="/summary" Method="GET" Call="GetSummary"/>  
<Route Url="/routines" Method="POST" Call="GetRoutineListByMask"/>
<Route Url="/routine" Method="POST" Call="GetRoutineData"/>
<Route Url="/test" Method="GET" Call="Test"/> 

</Routes>
]]></Data>
</XData>

<Method name="Http404">
<Description>
Issue an '404' error ( user can override)</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	&html<<h3 style="color:red">Страница не найдена!</h3>>
    Set %response.Status="404 Not Found"
    Quit $$$OK
]]></Implementation>
</Method>

<Method name="Test">
<ClassMethod>1</ClassMethod>
<PublicList>ok</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 x "set ok = 1"
    
	if ( ok ) { 
	  w "OK"
	}
	
  q $$$OK
]]></Implementation>
</Method>

<Method name="CheckMonitorStatus">
<Description>
Return monitor status</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  // if $zu(84,8) = 0 then Monitor stopped
  if ( $zu( 84, 8 ) = 0 ) {
    w "{ ""status"" : ""0"" }"
    q $$$OK
  }

  // if $zu(84,8) = 1 then Monitor started
  if ( $zu( 84, 8 ) = 1 ) {
    // if $zu(84,1) = 0 then Monitor started, but paused
    if ( $zu( 84, 1 ) = 0 ) {
      w "{ ""status"" : ""2"" }"
      q $$$OK
    }
    w "{ ""status"" : ""1"" }"
    q $$$OK
  }
]]></Implementation>
</Method>

<Method name="StartMonitor">
<Description>
Start Caché Monitor</Description>
<ClassMethod>1</ClassMethod>
<PublicList>ok</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set routineList = ""
	set rtn = ""
	//set ok = ""
	set content = ..ConvertRequestBody(%request.Content)
	
	if ($isobject(content)) {
		set routineList = content.routineList
	}
	
	
  lock +^|"%SYS"|SYS("MON-HOLD"):3

  // deselect all, prepare to incoming routine list
  do $zu(84, 12, 0)

  set j = 1
  set nlist = 0
  set rtnName = $piece(routineList, "|", j)
      
  while (rtnName '= "") {
    set rtnName = rtnName_".obj"

    do {
      set data = ""
      set more = $$LIST^%R(rtnName, 32767, 0, .data, .ctx)

      for i = 1 : 1 : $listlength(data) {
        set rtn = $list(data, i)
        set rtn = $piece(rtn, ".", 1, $length(rtn, ".") - 1)

        if ($znspace = "%SYS" && rtn = "START") {
          continue
        }

        x "zl "_rtn_" set ok = $zu(84, 12, 1)"

        if (ok) { 
          set nlist = nlist + 1
        }
      }
    } while more

    set j = j + 1
    set rtnName = $piece(routineList, "|", j)
  }

  if (nlist = 0) {
	  lock -^|"%SYS"|SYS("MON-HOLD")
	  w "{ ""status"" : ""0"" }"
    q $$$OK
  }

  // select all
  do $zu(84, 13, 2)

  // allocate memory and initialize data structures
  // (switch on monitoring)
  if ($zu(84, 0, 1, 1, 1, 1, 1, 1 ) '= 1) {
	  lock -^|"%SYS"|SYS("MON-HOLD")
	  w "{ ""status"" : ""-1"" }"
    q $$$OK
  }
 
  // enable stats for all jobs
  if ($zu( 84, 1, 1 ) '= 1) {
	  lock -^|"%SYS"|SYS("MON-HOLD")
	  w "{ ""status"" : ""-2"" }"
    q $$$OK
  }

  // enable line-by-line monitoring
  do $zu(84, 15)

  set ^|"%SYS"|SYS("MONITOR","START") = $h
  kill ^|"%SYS"|SYS("MONITOR","PAUSE"),^|"%SYS"|SYS("MONITOR","PAUSE-TIME")

  lock -^|"%SYS"|SYS("MON-HOLD")
	
	w "{ ""status"" : """_nlist_""" }"
  q $$$OK
]]></Implementation>
</Method>

<Method name="StopMonitor">
<Description>
Stop Caché Monitor</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  lock +^|"%SYS"|SYS("MON-HOLD"):3

  // disable stats
  set status = $zu(84, 1, 0)

  // end collection
  set status = $zu(84, 0, 0)

  kill ^|"%SYS"|SYS("MONITOR","START")
  kill ^|"%SYS"|SYS("MONITOR","PAUSE"),^|"%SYS"|SYS("MONITOR","PAUSE-TIME")

  lock -^|"%SYS"|SYS("MON-HOLD")
	
  w "{ ""status"" : """_status_""" }"
  q $$$OK
]]></Implementation>
</Method>

<Method name="ResumeMonitor">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	lock +^|"%SYS"|SYS("MON-HOLD"):3
  
  // Somebody already uses monitor 
  else  lock -^|"%SYS"|SYS("MON-HOLD") return -1

  // Monitor is not running
  if ( $zu( 84, 8 ) = 0 ) {
    lock -^|"%SYS"|SYS("MON-HOLD")
    w "{ ""status"" : ""-2"" }"
    q $$$OK
  }

  // Monitor already running
  if ( $zu( 84, 1 ) = 1 ) {
    lock -^|"%SYS"|SYS("MON-HOLD")
    w "{ ""status"" : ""-3"" }"
    q $$$OK
  }

  set zu84 = $zu( 84, 1, 1 )
  set h1 = $h

  if $d(^|"%SYS"|SYS("MONITOR","PAUSE")) {

    set x=((h1-^|"%SYS"|SYS("MONITOR","PAUSE"))*86400)+($p(h1,",",2)-$p(^|"%SYS"|SYS("MONITOR","PAUSE"),",",2))
    set ^|"%SYS"|SYS("MONITOR","PAUSE-TIME")=x+$g(^|"%SYS"|SYS("MONITOR","PAUSE-TIME"))
    kill ^|"%SYS"|SYS("MONITOR","PAUSE")
  }

  lock -^|"%SYS"|SYS("MON-HOLD")
  w "{ ""status"" : ""1"" }"
  q $$$OK
]]></Implementation>
</Method>

<Method name="PauseMonitor">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	lock +^|"%SYS"|SYS("MON-HOLD"):3

  // somebody already uses monitor 
  if ('$TEST) {
  	lock -^|"%SYS"|SYS("MON-HOLD") 
    w "{ ""status"" : ""-1"" }"
  	q $$$OK
  }

  // monitor is not running
  if ( $zu( 84, 8 ) = 0 ) {
    lock -^|"%SYS"|SYS("MON-HOLD")
    w "{ ""status"" : ""-2"" }"
  	q $$$OK
  }

  // monitor already paused
  if ( $zu( 84, 1 ) = 0) {
    lock -^|"%SYS"|SYS("MON-HOLD")
    w "{ ""status"" : ""-3"" }"
  	q $$$OK
  }

  // disable stats
  set zu84 = $zu( 84, 1, 0 )

  set ^|"%SYS"|SYS("MONITOR","PAUSE") = $h 
  lock -^|"%SYS"|SYS("MON-HOLD")

  w "{ ""status"" : ""1"" }"
  q $$$OK
]]></Implementation>
</Method>

<Method name="ResetStats">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	lock +^|"%SYS"|SYS("MON-HOLD"):3
	
  // clear stats
  set zu84 = $zu( 84, 2 )

  lock -^|"%SYS"|SYS("MON-HOLD")

  w "{ ""status"" : ""1"" }"
  q $$$OK
]]></Implementation>
</Method>

<Method name="GetRoutineListByMask">
<Description>
Get routine list by mask</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set routineList = ""
	set rtn = ""
	set content = ..ConvertRequestBody(%request.Content)
	
	if ($isobject(content)) {
		set routineList = content.routineList
	}
	
  lock +^|"%SYS"|SYS("MON-HOLD"):3

  // deselect all, prepare to incoming routine list
  do $zu(84, 12, 0)

  set j = 1
  set nlist = 0
  set rtnName = $piece(routineList, "|", j)
  set routinesByMask = ""
      
  while (rtnName '= "") {
    set rtnName = rtnName_".obj"

    do {
      set data = ""
      set more = $$LIST^%R(rtnName, 32767, 0, .data, .ctx)
			
      for i = 1 : 1 : $listlength(data) {
        set rtn = $list(data, i)
        set rtn = $piece(rtn, ".", 1, $length(rtn, ".") - 1)
				
        if ($znspace = "%SYS" && rtn = "START") {
          continue
        }
        
        set nlist = nlist + 1
        set routinesByMask = routinesByMask_$lb(rtn)
      }
    } while more
		
    set j = j + 1
    set rtnName = $piece(routineList, "|", j)
  }
	
	set routinesByMask = $listtostring(routinesByMask, "|")
	
  if (nlist = 0) {
	  lock -^|"%SYS"|SYS("MON-HOLD")
	  w "{ ""status"" : ""0"", ""routineList"" : """" }"
    q $$$OK
  }
  else {
	  lock -^|"%SYS"|SYS("MON-HOLD")
	  w "{ ""status"" : """_nlist_""", ""routineList"" : """_routinesByMask_""" }"
	  q $$$OK
  }
]]></Implementation>
</Method>

<Method name="GetSummary">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
		set index = $increment( ^CacheTemp )
	  $$$AddTempNode( ^CacheTemp( index ) )
	  
	  set sortIndex = -1
	  set rtnLine = -1
	  
	  for metric = 0 : 1 : ( $zutil( 84, 13 ) - 1 ) {
	    set n = $zutil( 84, 13, 11, metric )
	    
	    if ( n = 50 ) {
	      set sortIndex = metric
	    }
	    
	    if ( n = 33 ) {
	      set rtnLine = metric
	    }
	    
	  }

	  // $zu(84,16) returns number of routines being monitored
	  for rtnNum = 1 : 1 : ( $zu( 84, 16 ) ) {
	    // don't report on routines with no lines executed
	    if $zu( 84, 16, 1, rtnNum ) = 0 {
	      continue
	    }

	    kill metric
	    set hits = 0
	    // zero coverage stats
	    if $zutil( 84, 16, 1, rtnNum ) = 0 {
	      // get number of lines in routine
	      set line = $$LENGTH^%R( $zu( 84, 16, 2, rtnNum ) )

	      if ( line = 0 ) { 
	        set metric( -1 ) = -1
	        set metric( -2 ) = 0
	        set metric( -3 ) = "NA"
	      }
	      else {
	        set metric( -1 ) = 0
	        set metric( -2 ) = 0
	        set metric( -3 ) = line
	      }
	    }

	    // for each routine line
	    for line = 0 : 1 : ( $zu( 84, 16, 1, rtnNum ) - 1 ) {
	    // for each metric
	      for i = 0 : 1 : ( $zu( 84, 13 ) - 1 ) {
	        set metric( i ) = $get( metric( i ) ) + $zu( 84, 16, 3, line, i )
	      }

	      if $zu( 84, 16, 3, line, rtnLine ) {
	        set hits = hits + 1
	      }
	    }

	    set line = $zu( 84, 16, 7, rtnNum )
	    set metric( -3 ) = line
	    set metric( -2 ) = hits
	    set metric( -1 ) = +$fnumber( hits / line * 100, "", 2)

	    // $zu(84,16,2,rtn_n) returns routine name by number
	    set rtn = $zu( 84, 16, 2, rtnNum )

	    if ( sortIndex = -1 ) {
	      set sort = sortIndex
	    }
	    else {
	      set sort = metric( sortIndex )
	    }

	    merge ^CacheTemp( index, sort, rtn ) = metric
	  }

	  kill totmetric
	  kill summary

	  set count = 0
	  set sort = $order( ^CacheTemp( index, "" ), -1 )

	  while ( sort '= "" ) {
	    set rtn = $order( ^CacheTemp( index, sort, "" ) )

	    while ( rtn '= "" ) {
	      set summary( rtn ) = count
	      set count = count + 1
	      set metric = $order( ^CacheTemp( index, sort, rtn, "" ), 1, out)

	      while ( metric '= "" ) {
	        set totmetric( metric ) = $get( totmetric( metric ) ) + out
	        // handle coverage percent
	        if ( metric = -3 ) {
	          set out = $select( out = -1:"NA", 1:out)
	          set summary( rtn, "LinesCode" ) = out
	        }
	        
	        if ( metric = -2 ) {
	          set out = $select( out = -1:"NA", 1:out )
	          set summary( rtn, "LinesHit" ) = out
	        }
	        
	        set n = ""
	        
	        if ( metric '< 0 ) {
	          set n = $zu( 84, 13, 11, metric )
	        }
	        
	        if ( ( n = 50 ) || ( n = 51 ) ) {
	          set out = $select( out = 0:"0", 1:$fnumber( out / 1000000, "", 6 ))
	        }
	        
	        // don't accumulate total time, it doesn't make sense
	        if ( n = 50 ) {
	          set summary( rtn, "Time" ) = out
	        }

	        set metric = $order( ^CacheTemp( index, sort, rtn, metric ), 1, out )
	      }

	      set rtn = $order( ^CacheTemp( index, sort, rtn ) )
	    }

	    set sort = $order( ^CacheTemp( index, sort ), -1 )
	  }

	  kill ^CacheTemp( index )
	  $$$RemoveTempNode( ^CacheTemp( index ) )

	  set json = "["
	  set rtn = $order( summary( "" ) )
	  
	  while ( rtn '= "" ) {
	    set json = json_"{""Routine"":"""_rtn_
	                    """,""LinesCode"":"""_summary( rtn, "LinesCode" )_
	                    """,""LinesHit"":"""_summary( rtn, "LinesHit" )_
	                    """,""Time"":"""_summary( rtn, "Time" )_"""},"
	    set rtn = $order( summary( rtn ) )              
	  }

	  if ( json '= "[" ) {
	    set json = $extract( json, 1, *-1 )_"]"
	  }
	  else {
	    set json = ""
	  }

	  w json
	  
	  return $$$OK
]]></Implementation>
</Method>

<Method name="GetRoutineData">
<ClassMethod>1</ClassMethod>
<FormalSpec>rtnName</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set stream = ##class(%Stream.TmpCharacter).%New()
    set outStream = ##class(%Stream.TmpCharacter).%New()
    set colorer = ##class(%SyntaxColor).%New()
    set visitor = ##class(GMONLBL.Visitor).%New()
    
    set content = ..ConvertRequestBody(%request.Content)
    set rtnName = content.rtnName

    // find routine
    set rtnNum = $zutil(84, 16)
    set found = 0

    for rtn = 1 : 1 : rtnNum {
      if ( rtnName = $zutil(84, 16, 2, rtn) ) {
        set found = 1
        quit
      }
    }

    if ('found) return $$$OK


    // collect routine data
    set lines = $zutil(84, 16, 1, rtn)


    if (lines = 0 ) return $$$OK

    for line = 0 : 1 : ( lines - 1 ) {
      kill map
      set list = ""

      set data = $zutil( 84, 16, 3, line, 33 )
      set list = list_$listbuild( data )

      // line time
      set data = $zutil(84, 16, 3, line, 50)
      // convert clock/CPU time to seconds
      set data = $select(data = 0:0, 1:$fnumber(data / 1000000, "", 6))
      set list = list_$listbuild(data)

      set localTime = data

      // total time
      set data = $zutil(84, 16, 3, line, 51)
      // convert clock/CPU time to seconds
      set data = $select(data = 0:0, 1:$fnumber( data / 1000000, "", 6))
      set list = list_$listbuild(data)

      set totalTime = data

      set codeLine = $$LINE^%R(rtnName, line + 1)

      set visitor.Routines = ""
      set visitor.Classes = ""
      set visitor.Methods = ""
      set rtnNamesList = ""

      // Missing lines without routine calls
      if (totalTime > localTime) {

        set tree = ##class(%Compiler.COS.ParseTree).Parse( codeLine, ,.sc )

        if ( 'sc ) {
          set tree = ""
        }
        
        kill classList
        kill methodList
        
        if ( tree '= "" ) {

          do tree.accept( visitor )

          set routines = visitor.Routines
          
          set rtnNamesList = ""
          
          set classList = visitor.Classes
          set methodList = visitor.Methods
                 
          if ( $listlength( routines ) ) {
            for k = 1 : 1 : $listlength( routines ) {
              
              set routine = $piece( $list( routines, k ), "^", 2 )
              set method = $piece( $list( routines, k ), "^", 1 )
              
              if ( method '= "" ) {
                do ##class(%Studio.Debugger).INTLine( routine_".MAC", method, 0, .intName, .intLine)

                if ( intName '= "" ) {
                  set rtnNamesList = rtnNamesList_intName_"~"_intLine_"~"_method_"|"
                } 
              }
              else {
                if ( routine'= "" ) {
                  set rtnNamesList = rtnNamesList_routine_"|"
                }
              }
            } 
          }            
          
          if ( $listlength( classList ) ) {
            for k = 1 : 1 : $listlength( classList ) {
              do ##class(%Studio.Debugger).INTLine( $li( classList, k)_".CLS", $li( methodList, k ), 0, .intName, .intLine)

              if ( intName '= "" ) {
                set rtnNamesList = rtnNamesList_intName_"~"_intLine_"~"_$li( methodList, k )_"|"
              } 
            } 
          }          
            
          if ( rtnNamesList '= "" ) {
            set rtnNamesList = $extract( rtnNamesList, 1, *-1 )
          }

        }

      }

      do stream.WriteLine( codeLine )
      do colorer.Color( stream, outStream )

      set codeLine = $replace( outStream.ReadLine(), "\", "\\" )
      set codeLine = $replace( codeLine, $char( 09 ), "\t" )
      set codeLine = $replace( codeLine, """", "\""" )

      set list = list_$listbuild( codeLine )
      set list = list_$listbuild( rtnNamesList )

      set totalData( line + 1 ) = list
    }


    // Assambling JSON
    set json = "["

    for line = 1 : 1 : lines {
      set list = totalData( line )
      
      set json = json_"{""RtnLine"":"""_$li( list, 1 )_
                       """,""Time"":"""_$li( list, 2 )_
                       """,""TotalTime"":"""_$li( list, 3 )_
                       """,""Line"":"""_$li( list, 4 )_
                       """,""Calls"":"""_$li( list, 5 )_
                       """},"
    }  


    if ( json '= "[" ) {
      set json = $extract( json, 1, *-1 )_"]"
    }
    else {
      set json = ""
    }

    w json
    return $$$OK
]]></Implementation>
</Method>

<Method name="ConvertRequestBody">
<Description>
Converts request into UTF8. Converts request into proxyObject. </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>content</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim obj As %ZEN.proxyObject

	return:'$isobject(content) $$$OK //empty request body - nothing to do
	
	// Convert request body into UTF8 proxyObject
	set content = content.Read($$$MaxStringLength)
	set content = $ZCVT(content,"I","UTF8") 
	set st = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(content,,.obj,1)
	return:$$$ISERR(st) st
	return:'$IsObject(obj) $$$ERROR($$$ArgumentIsNotAnObject,"Body")
	
	set content = obj // obj here is a valid UTF8 proxyObject with required property
	return content
]]></Implementation>
</Method>
</Class>
</Export>
