<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="GMONLBL.Installer">
<IncludeCode>%occInclude</IncludeCode>
<TimeCreated>63481,77165.410085</TimeCreated>

<XData name="Install">
<Description>
See generated code in zsetup+1^GMONLBL.Installer.1
todo add optional parameter WEBAPP to Alter web app name if it needs to have another then namespace name</Description>
<XMLNamespace>INSTALLER</XMLNamespace>
<Data><![CDATA[
<Manifest>
<IfNotDef Var="Namespace">
<Var Name="Namespace" Value="MONLBLVIEWER"/>
<Log Text="Set namespace to ${Namespace}" Level="0"/>
</IfNotDef>
<If Condition='(##class(Config.Namespaces).Exists("${Namespace}")=0)'>
<Log Text="Creating namespace ${Namespace}" Level="0"/>
<Namespace Name="${Namespace}" Create="yes" Code="${Namespace}" Ensemble="" Data="${Namespace}">
<Configuration>
<Database Name="${Namespace}" Dir="${MGRDIR}/${Namespace}" Create="yes" MountRequired="true" Resource="%DB_${Namespace}" PublicPermissions="RW" MountAtStartup="true"/>
</Configuration>
</Namespace>
 <Log Text="End Creating namespace ${Namespace}" Level="0"/>
</If>

<Namespace Name="${Namespace}" Create="no">
<IfDef Var="SourceDir">
<Log Text="SourceDir defined - offline install from ${SourceDir}" Level="0"/>
<Import File="${SourceDir}"/>
</IfDef>
<IfNotDef Var="SourceDir">
<Log Text="SourceDir undefined - online install from GitHub" Level="0"/>
<RunInstall Class="GMONLBL.Installer" Method="DownloadFromGitHub"/>
</IfNotDef>
<If Condition='(##class(Security.Applications).Exists("/"_"${Namespace}")=0)'>
    <Log Text="Creating web application /${Namespace}" Level="0"/>
    <!-- This method creates conflits with web-server. Kept for reference purposes. See ##class(%EnsembleMgr).createPortalApp()
    <CSPApplication Url="/${Namespace}" Directory="" AuthenticationMethods="64" IsNamespaceDefault="false" />-->
    <RunInstall Class="GMONLBL.Installer" Method="CreateWebApp"/>
</If>
<If Condition='(##class(Security.Applications).Exists("/"_"${Namespace}"_"/rest")=0)'>
    <Log Text="Creating web application /${Namespace}" Level="0"/>
    <!-- This method creates conflits with web-server. Kept for reference purposes. See ##class(%EnsembleMgr).createPortalApp()
    <CSPApplication Url="/${Namespace}" Directory="" AuthenticationMethods="64" IsNamespaceDefault="false" />-->
    <RunInstall Class="GMONLBL.Installer" Method="CreateRESTApp"/>
</If>
</Namespace>

<If Condition='(##class(Config.Namespaces).Exists("%All")=0)'>
<Log Text="Creating namespace %All" Level="0"/>
<Namespace Name="%All" Create="yes" Code="CACHETEMP" Data="CACHETEMP" Ensemble="0">
<Configuration/>
</Namespace>
</If>

<Log Text="Mapping GMONLBL package to %All namespace" Level="0"/>
<Namespace Name="%All" Create="no">
<ClassMapping From="${Namespace}" Package="GMONLBL"/> 
</Namespace>

<Log Text="Mapping GMONLBL package to Samples namespace" Level="0"/>
<Namespace Name="Samples" Create="no">
<ClassMapping From="${Namespace}" Package="GMONLBL"/> 
</Namespace>
</Manifest>
]]></Data>
</XData>

<Method name="setup">
<Description>
This is a method generator whose code is generated by XGL.
set pVars("Namespace")="TEMPNS"
set pVars("SourceDir")="C:\temp\GMONLBL\GMONLBL"
do ##class(GMONLBL.Installer).setup(.pVars)</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<FormalSpec><![CDATA[&pVars,pLogLevel:%Integer=0,pInstaller:%Installer.Installer]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[    quit ##class(%Installer.Manifest).%Generate(%compiledclass, %code, "Install")
]]></Implementation>
</Method>

<Method name="CreateWebApp">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVars,pLogLevel,tInstaller</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set Namespace=tInstaller.Evaluate("${Namespace}")
    do tInstaller.PushNS("%SYS")
    do ##class(Security.System).GetInstallationSecuritySetting(.security)
    
    if (security = "None") {
        /* unauthenticade */
        set cspProperties("AutheEnabled") = 64
    } else {
        /* password */
        set cspProperties("AutheEnabled") = 32
    }
    
    set cspProperties("NameSpace") = Namespace
    set cspProperties("IsNameSpaceDefault") = 1
    set tSC = ##class(Security.Applications).Create("/gmonlbl", .cspProperties)
    
    do tInstaller.PopNS()
    
    if $$$ISERR(tSC) Throw ##class(%Installer.Exception).CreateFromStatus(tSC)
    quit $$$OK
]]></Implementation>
</Method>

<Method name="CreateRESTApp">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVars,pLogLevel,tInstaller</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set Namespace = tInstaller.Evaluate("${Namespace}")
    do tInstaller.PushNS("%SYS")
    do ##class(Security.System).GetInstallationSecuritySetting(.security)
    
    if (security = "None") {
        /* unauthenticade */
        set cspProperties("AutheEnabled") = 64
    } else {
        /* password */
        set cspProperties("AutheEnabled") = 32
    }
    
    set cspProperties("NameSpace") = Namespace
    set cspProperties("IsNameSpaceDefault") = 0
    set cspProperties("DispatchClass") = "GMONLBL.Broker"
    
    set tSC = ##class(Security.Applications).Create("/gmonlbl/rest", .cspProperties)
    
    do tInstaller.PopNS()
    
    throw:$$$ISERR(tSC) ##class(%Installer.Exception).CreateFromStatus(tSC)
    quit $$$OK
]]></Implementation>
</Method>

<Method name="DownloadFromGitHub">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVars,pLogLevel,tInstaller</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set Namespace = tInstaller.Evaluate("${Namespace}")
    do tInstaller.PushNS("%SYS")
    
    set tSC = ..Update(Namespace, "intersystems-ru", "monlbl-viewer", "master")
    
    do tInstaller.PopNS()
    
    throw:$$$ISERR(tSC) ##class(%Installer.Exception).CreateFromStatus(tSC)
    quit $$$OK
]]></Implementation>
</Method>

<Method name="Update">
<Description><![CDATA[
Downloads and compiles GitHub repository.<br>
 <b>Owner</b> - The name of the repository owner.<br>
 <b>Repository</b> - The name of the repository.<br>
 <b>Branch</b> - The name of the commit/branch/tag. If skipped the repository’s default branch (usually master) would be used.<br>
 <b>Username</b> - GitHub user, who has access to repository. Optional for public repositories.<br>
 <b>Password</b> - GitHub password, corresponding to Username. Optional for public repositories.<br>
 Note, that with Username, you can make up to 5,000 requests per hour. 
 For unauthenticated requests, the rate limit allows to make up to 60 requests per hour. 
 Unauthenticated requests are associated with an IP address.<br>
 <b>Namespace</b> - Namespace, where to download and compile repository.<br>
 
 For example in the repository: https://github.com/intersystems-ru/monlbl-viewer<br>
 Owner - intersystems-ru, Repository - monlbl-viewer.<br> ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Namespace=$Namespace,Owner:%String="intersystems-ru",Repository:%String="monlbl-viewer",Branch:%String,Username:%String,Password:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set namespace = $Namespace
    set SSLConfig = "GitHub"
    
    zn "%SYS"
    do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)

    set req=##class(%Net.HttpRequest).%New()
    set req.Https = 1
    set req.SSLConfiguration=SSLConfig
    set req.Server="api.github.com"
    /* as described in https://developer.github.com/v3/repos/ */
    set req.Location = "repos/" _ Owner _ "/" _ Repository _ "/contents"      
       
    /* if omitted the repository’s default branch (usually master) would be used */
    do:$d(Branch) req.SetParam("ref", Branch)              
    /* we want to receive API v3 */               
    do req.SetHeader("Accept", "application/vnd.github.v3+json")             
    
    /* supply Username and Password, if both are provided. GitHub accept Basic Auth
    // https://developer.github.com/v3/auth/ */
    if ($d(Username) && $d(Password)) {                                     
        set req.Username = Username                                         
        set req.Password = Password
    }   

    set links = ##class(%ListOfDataTypes).%New()
    set st = ..ProcessDirectory("", req, .links)
    return:$$$ISERR(st) st
        
    zn Namespace
    set st = ..DownloadFiles(links, req, .list)
    set st2 = $system.OBJ.CompileList(.list)
    zn namespace
    
    return $$$ADDSC(st, st2)
]]></Implementation>
</Method>

<Method name="ProcessDirectory">
<Description><![CDATA[
Process one directory of GitHub repository. Recursive.<br>
<b>Path</b> -Internal repository path. Root is empty string<br>
<b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
<b>Links</b> - List of links to raw files (which satisfy <b>IsCacheFile</b> conditions) from repository.<br>]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[Path:%String="",Request:%Net.HttpRequest,&Links:%ListOfDataTypes]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set location = Request.Location
    set Request.Location = Request.Location _ Path
    
    set st = Request.Get()
    
    return:$$$ISERR(st) st
    return:(Request.HttpResponse.StatusCode = 404) $$$ERROR($$$GeneralError, "Repository doesn't exist OR you don't have access")
    return:((Request.HttpResponse.StatusCode = 403) && (Request.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) $$$ERROR($$$GeneralError, "API rate limit exceeded. Try logging in.")
    return:(Request.HttpResponse.StatusCode '= 200) $$$ERROR($$$GeneralError, "Received " _ Request.HttpResponse.StatusCode _ " status, expected 200")
    
    #dim objects As List of %ZEN.proxyObject
    #dim obj As %ZEN.proxyObject
    set st = ##class(%ZEN.Auxiliary.jsonProvider).%ConvertJSONToObject(Request.HttpResponse.Data,, .objects, 1)
    return:$$$ISERR(st) st
    
    for i = 1 : 1 : objects.Count() {       
        set obj = objects.GetAt(i)
        
        if (obj.type = "dir") {
            set st = ..ProcessDirectory("/"_obj.name, Request, .Links)
            return:$$$ISERR(st) st      
        } elseif (obj.type = "file") {
            do:..IsCacheFile(obj) Links.Insert(obj."download_url")
        } else {
            // obj.type = "symlink" or obj.type = "submodule"
        } 
    }
    
    /* to keep track of where in the repository tree we are */
    set Request.Location = location 
    return $$$OK
]]></Implementation>
</Method>

<Method name="IsCacheFile">
<Description>
Check that incoming file is the one you need.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>File:%ZEN.proxyObject</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
    set extensions = ",xml,cls,csp,csr,mac,int,bas,inc,gbl,prj,obj,pkg,gof,"
    return:($l(File.name,".") = 1) 0 // no extension
    set File.Extension = $p(File.name, ".", $l(File.name,"."))
    return $F(extensions, ","_$ZCVT(File.Extension,"l")_",")
]]></Implementation>
</Method>

<Method name="DownloadFiles">
<Description><![CDATA[
Download list of files on https://raw.githubusercontent.com/ server.<br>
<b>Links</b> - List of links to raw files.<br>
<b>Request</b> - Authenticated/Set %Net.HttpRequest object.<br>
<b>loadedlist</b> - Returns an array of the items loaded. ]]></Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Links:%ListOfDataTypes,Request:%Net.HttpRequest,*Items</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    kill Items
    set Request.Server = "raw.githubusercontent.com"
    set st = $$$OK
    
    for i = 1 : 1 : Links.Count() {
        /* remove "https://raw.githubusercontent.com/" from URL */
        set streq = Request.Get($e(Links.GetAt(i), 35, *))   
        set:$$$ISERR(streq) st=$$$ADDSC(st, streq)
        
        set binarystream = Request.HttpResponse.Data
        do binarystream.Rewind() // just in case
        
        /* translating binary stream into character stream */
        set stream=##class(%GlobalCharacterStream).%New() 
        while 'binarystream.AtEnd { 
            do stream.Write(binarystream.Read()) 
        }
        
        do stream.Rewind()

        set stload = $system.OBJ.LoadStream(stream, "", .error, .items,,,, "UTF8")
        set:$$$ISERR(stload) st = $$$ADDSC(st, stload)
        
        /* does not overwrite existing array keys: Items(itemname) = "" */
        merge Items = items  
    }
    
    set Request.Server="api.github.com"
    return st
]]></Implementation>
</Method>

<Method name="RevokePublicPriveleges">
<Description>
Revokes all access of _PUBLIC user to everything in comma-separated list of namespaces</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>NamespacesList:%String="*"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    set:(NamespacesList = "*") NamespacesList = ..GetNSList()
    set basens = $Namespace
    set st = $$$OK
    
    for i = 1 : 1 : $l(NamespacesList, ",") {
        zn $p(NamespacesList, ",", i)
        set st1 = $SYSTEM.SQL.RevokeObjPriv("SELECT", "*", "TABLE", "_PUBLIC",,, "_SYSTEM")
        set st2 = $SYSTEM.SQL.RevokeObjPriv("SELECT", "*", "VIEW", "_PUBLIC",,, "_SYSTEM")
        set st3 = $SYSTEM.SQL.RevokeObjPriv("SELECT", "*", "CUBES", "_PUBLIC",,, "_SYSTEM")
        set st4 = $SYSTEM.SQL.RevokeObjPriv("SELECT", "*", "STORED PROCEDURES", "_PUBLIC",,, "_SYSTEM")
        set st = $$$ADDSC(st, $$$ADDSC(st1, $$$ADDSC(st2, $$$ADDSC(st3, st4))))
    }
    
    zn basens
    return st
]]></Implementation>
</Method>

<Method name="GetNSList">
<Description>
Returns comma-separated list of all local availible namespaces</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
    set st = ##class(%CSP.Portal.Utils).%GetNamespaceList(.nsarrary)
    return:$$$ISERR(st) st
    set namespace = $o(nsarrary(""))
    set nslist = ""
    
    while namespace '= "" {
        set enabled = $lg(nsarrary(namespace), 1)
        set remote = $lg(nsarrary(namespace), 2)
        
        if ((enabled = 1) && (remote = 0)) {
            set nslist = nslist_namespace_"," 
        }
        
        set namespace = $o(nsarrary(namespace))
    }
    
    return $e(nslist, 1, *-1)
]]></Implementation>
</Method>
</Class>
</Export>
